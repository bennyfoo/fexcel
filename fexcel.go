package main

import (
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"time"

	"github.com/blang/semver"
	"github.com/onerobotics/fexcel/commenter"
)

const VERSION = "1.1.0"

var (
	defaultSheet string
	offset       int
	noUpdate     bool
	cfg          commenter.Config
)

const logo = `  __                  _
 / _|                | |
| |_ _____  _____ ___| |
|  _/ _ \ \/ / __/ _ \ |
| ||  __/>  < (_|  __/ |
|_| \___/_/\_\___\___|_|
                  v1.1.0

by ONE Robotics Company
www.onerobotics.com

`

type releaseResponse struct {
	Url     string `json:"url"`
	TagName string `json:"tag_name"`
	Assets  []struct {
		DownloadUrl string `json:"browser_download_url"`
	} `json:"assets"`
}

func checkForUpdates(w io.Writer) error {
	fmt.Fprintf(w, "\nChecking for updates... ")

	githubClient := http.Client{
		Timeout: 2 * time.Second,
	}

	req, err := http.NewRequest("GET", "https://api.github.com/repos/onerobotics/fexcel/releases/latest", nil)
	if err != nil {
		return err
	}

	req.Header.Set("User-Agent", "fexcel-v"+VERSION)

	res, err := githubClient.Do(req)
	if err != nil {
		return err
	}
	defer res.Body.Close()

	var response releaseResponse
	err = json.NewDecoder(res.Body).Decode(&response)
	if err != nil {
		return err
	}

	if len(response.Assets) != 1 {
		return fmt.Errorf("Invalid # of assets: %d", len(response.Assets))
	}

	currentVersion, err := semver.Make(VERSION)
	if err != nil {
		return err
	}
	latestVersion, err := semver.Make(response.TagName[1:]) // tag has v prefix
	if err != nil {
		return err
	}

	if latestVersion.GT(currentVersion) {
		fmt.Fprintf(w, "A new version is available!\n")
		fmt.Fprintf(w, "  The latest version is: %s. You are on v%s\n", response.TagName, VERSION)
		fmt.Fprintf(w, "  You can view the latest release here:\n    %s\n", response.Url)
		fmt.Fprintf(w, "  You can download the latest release here:\n    %s\n", response.Assets[0].DownloadUrl)
	} else {
		fmt.Fprintf(w, "You are on the latest version: v%s\n", VERSION)
	}

	return nil
}

func usage() {
	fmt.Fprintf(os.Stderr, logo)
	fmt.Fprintf(os.Stderr, "Usage: fexcel [options] filename host(s)...\n\n")

	fmt.Fprintf(os.Stderr, "Example: fexcel -sheet Data -numregs A2 -posregs Sheet2:D2 -timeout 1000 spreadsheet.xlsx 127.0.0.101 127.0.0.102\n\n")
	fmt.Fprintf(os.Stderr, "Options:\n")
	flag.PrintDefaults()

	err := checkForUpdates(os.Stderr)
	if err != nil {
		fmt.Fprintf(os.Stderr, "\n  Error: %s\n", err.Error())
	}

	os.Exit(1)
}

func init() {
	flag.StringVar(&defaultSheet, "sheet", "Sheet1", "the name of the default sheet to look at if the sheet is not specified for an item")
	flag.IntVar(&offset, "offset", 1, "column offset from ids to comments")
	flag.BoolVar(&noUpdate, "noupdate", false, "don't check for updates to fexcel")
	flag.StringVar(&cfg.Numregs, "numregs", "", "start cell of numeric register ids (e.g. A2 or Sheet2:A2)")
	flag.StringVar(&cfg.Posregs, "posregs", "", "start cell of position register ids (e.g. A2 or Sheet2:A2)")
	flag.StringVar(&cfg.Ualms, "ualms", "", "start cell of user alarm ids (e.g. A2 or Sheet2:A2)")
	flag.StringVar(&cfg.Rins, "rins", "", "start cell of robot input ids (e.g. A2 or Sheet2:A2)")
	flag.StringVar(&cfg.Routs, "routs", "", "start cell of robot output ids (e.g. A2 or Sheet2:A2)")
	flag.StringVar(&cfg.Dins, "dins", "", "start cell of digital input ids (e.g. A2 or Sheet2:A2)")
	flag.StringVar(&cfg.Douts, "douts", "", "start cell of digital output ids (e.g. A2 or Sheet2:A2)")
	flag.StringVar(&cfg.Gins, "gins", "", "start cell of group input ids (e.g. A2 or Sheet2:A2)")
	flag.StringVar(&cfg.Gouts, "gouts", "", "start cell of group output ids (e.g. A2 or Sheet2:A2)")
	flag.StringVar(&cfg.Ains, "ains", "", "start cell of analog input ids (e.g. A2 or Sheet2:A2)")
	flag.StringVar(&cfg.Aouts, "aouts", "", "start cell of analog output ids (e.g. A2 or Sheet2:A2)")
	flag.StringVar(&cfg.Sregs, "sregs", "", "start cell of string register ids (e.g. A2 or Sheet2:A2)")
	flag.StringVar(&cfg.Flags, "flags", "", "start cell of flag ids (e.g. A2 or Sheet2:A2)")
	flag.IntVar(&cfg.Timeout, "timeout", 500, "timeout value in milliseconds")
}

func check(err error) {
	if err != nil {
		fmt.Println("Error:", err)
		os.Exit(1)
	}
}

func main() {
	flag.Parse()

	args := flag.Args()
	if len(args) < 2 {
		usage()
	}

	filename := args[0]
	if filename == "" {
		usage()
	}

	ext := filepath.Ext(filename)
	if ext != ".xlsx" {
		fmt.Fprintf(os.Stderr, "Error: fexcel only supports .xlsx files generated by Excel 2007 or later")
		os.Exit(1)
	}

	hosts := args[1:]

	fmt.Printf(logo)

	c, err := commenter.New(filename, defaultSheet, offset, cfg, hosts)
	check(err)

	result, err := c.Update()
	if err != nil {
		fmt.Printf("Error: %s\n", err)
		os.Exit(1)
	}

	fmt.Printf("-------------------------------------\n")
	fmt.Printf("Hosts:\n")
	for _, host := range hosts {
		fmt.Printf("  %s\n", host)
	}
	fmt.Printf("-------------------------------------\n")

	fmt.Printf("Data              | I/O       In  Out\n")
	fmt.Printf("------------------|------------------\n")
	fmt.Printf("Flags        %4d | Analog  %4d %4d\n", result.Flags, result.Ains, result.Aouts)
	fmt.Printf("Numregs      %4d | Digital %4d %4d\n", result.Numregs, result.Dins, result.Douts)
	fmt.Printf("Posregs      %4d | Group   %4d %4d\n", result.Posregs, result.Gins, result.Gouts)
	fmt.Printf("Sregs        %4d | Robot   %4d %4d\n", result.Sregs, result.Rins, result.Routs)
	fmt.Printf("UALMs        %4d |\n", result.Ualms)

	if !noUpdate {
		err = checkForUpdates(os.Stdout)
		if err != nil {
			fmt.Printf("\n  Error: %s\n", err.Error())
		}
	}
}
